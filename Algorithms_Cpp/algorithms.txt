Kahn's Algorithm:
1. compute in-degrees (how many incoming edges there are for each vertex)
2. vertices with indegree of 0 are added to queue. remove a vertex, add to result, reduce indegree of all of its adjacent vertices
3. if you have an indegree of 0 again, add to queue... repeat

Prim's Algorithm:
- Starting at a random point, it observes all connected edges and then picks the shortest one that hasn't been picked previously
- continues until the queue is empty i suppose
- if not all values were traversed, then pick a new starting point and keep going. (similar to bfs)


BFS:



Bellman-Ford's Algorithm
- works with negative edges (lines)
- iterates N-1 times with N being the number of vertices (points)
- also uses Parent and Dist
- re-checks every edge for a potential shorter distance instead of just the closest ones (like in Dijkstra)

  note: can look for negative cycles (looping things with the value decreasing)
  - after N-1 cycles, if, in the next cycle, there is more change to the array of (distance, vertex), then there's 
    a negatiive cycle


k shortest path:
- restricts parts of the graph to get different paths = different differencess
- get a list of all of the distances (apparently) and returns the shortest k ones



Dijkstra's Algorithm
- only works for non-negative
src = 0, everything else = infinity

Dist[vertex] = the current shortest value of all the edges to go to point V from source

min-priority queue:
- originaly stores (0, source)
- stores (distance, vertex)
You add all of the next vertices that are connected,
you remove the vertice with the smallest distance

Say you remove vertice U, 
  U -> V (weight N)
   For vertices V and W going off of U, if dist [V] > dist [U] + N, then you found a shorter path
   and you update dist[V] = dist[U] + N

Parent:
  parent[V] = U means that U is the vertice before V in the best path to V
  - used to reconstruct the best path 
  - originally, parent[src] = -1

Other Info:
  Source (src) = the point that you start at
