	//Application temple 
	
	#include "HardwareInfo.c"
	#include "JMLib.c"
	#include <GetCompassB.h>
	#include <SetMotor.h>
	#include <GetAdUltrasound.h>
	#include <SetLCD5Char.h>
	#include <GetCompoI3.h>
	#include <SetCentiS.h>
	#include <GetADScable10.h>
	#include <SetLCDSolidCircle.h>
	#include <GetSysTimeMs.h>
	#include <stm32f4xx.h>
	
	
	
	//0 is counter clockwise, 2 is clockwise
	int compass, right, left, front, back, difference, whiteRight, whiteLeft, whiteBack, whiteFront, startTime;
	int speed = 40;
	int turnSpeed=10;
	int xdifference, ydifference;
	int lwhere, rwhere,ldist, rdist;
	int where, dist;
	int isRight; //0 is false, 1 is traue
	int doMove=0;
	int moveRatio = 0.1; //ratio for movetopose
	int isHoriBlin d, isVertiBlind;
	
	//negative speed is 0, positive is 2
	
	
	int getBallDirection(){
		int n;
		if(lwhere == 7 && rwhere == 1){
			n = 0;
		}else if (isRight == 1){ // right side
			n = rwhere * 30 - 30;
		}else{
			n = 30*lwhere + 150;
		}
		return n;
	}
	
	
	void move(int d, int s){
		double x, radians;
		int s1, s2, s3, s4;
		if(d>=0 && d<45){
			d=45-d;
			radians = d*3.14/180;
			 x = s*tan(radians); 
			s1= -x;
			s2=-s;
			s3=x;
			s4=s;
		}else if(d>=45 && d<90){
			d=d-45;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1= x;
			s2=-s;
			s3=-x;
			s4=s;
		}else if(d>=90 && d<135){
			d=135-d;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1=s;
			s2=-x;
			s3=-s;
			s4=x;
		}else if(d>=135 && d<180){
			d=d-135;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1=s;
			s2=x;
			s3=-s;
			s4=-x;
		}else if(d>=180 && d<225){
			d=225-d;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1=x;
			s2=s;
			s3=-x;
			s4=-s;
		}else if(d>=225 && d<270){
			d=d-225;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1=-x;
			s2=s;
			s3=x;
			s4=-s;
		}else if(d>=270 && d<315){
			d=315-d;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1=-s;
			s2=x;
			s3=s;
			s4=-x;
		}else if(d>=315 && d<360){
			d=d-315;
			 radians = d*3.14/180;
			 x = s*tan(radians);
			s1=-s;
			s2=-x;
			s3=s;
			s4=x;
		}
		int d1 = 2;
		int d2 = 2; 
		int d3 = 2;
		int d4 = 2;
	
		
		if(compass > 10 && compass < 350){
		
			if(compass > 45  && compass < 181){ //facing the right
				s1 = turnSpeed;
				s2 = turnSpeed;
				s3 = turnSpeed;
				s4 = turnSpeed;
				d1 = 2;
				d2 = 2;
				d3 = 2;
				d4 = 2;
			}else if (compass > 180 && compass < 315){ // facing left
				s1 = turnSpeed;
				s2 = turnSpeed;
				s3 = turnSpeed;
				s4 = turnSpeed;
				d1 = 0;
				d2 = 0;
				d3 = 0;
				d4 = 0;	
			}else {
			
				if(compass <=  45){ 
					s1+=compass/3;
					s2+=compass/3;
					s3+= compass/3;
					s4 += compass/3;
					
				}else{				
					s1 -= (360-compass)/3;
					s2 -= (360-compass)/3;
					s3-= (360-compass)/3;
					s4-= (360-compass)/3;	
				}
				 
			}
			
		} 
		
		
		
		if (s1<0){
			d1=0;
			s1=abs(s1);
		}
		
		if (s2<0){
			d2=0;
			s2=abs(s2);
		}
		
		if (s3<0){
			d3=0;
			s3=abs(s3);
		}
	
		if (s4<0){
			d4=0;
			s4=abs(s4);
		}
	
	
	
		if(d>360 || d<0){ //stop robot
			if ((compass < 8 && compass > -1) ||  (compass > 353 && compass < 361)){ //face forward, stop
				d1=1;
				d2=1;
				d3=1;
				d4=1;
				s1 = 0;
				s2 = 0;
				s3 = 0;
				s4 = 0; 
			}else{
				if(compass <352 && compass >181){ //turn right
					s1 = turnSpeed;
					s2 = turnSpeed;
					s3 = turnSpeed;
					s4 = turnSpeed;
					d1 = 0; 
					d2 = 0;
					d3 = 0;
					d4 = 0;
				}else if(compass >7 && compass <180){//turn left
					s1 = turnSpeed;
					s2 = turnSpeed;
					s3 = turnSpeed;
					s4 = turnSpeed;
					d1 = 2; 
					d2 = 2;
					d3 = 2;
					d4 = 2;
				}
	
			}
			
		} 
		
		if(s1>80){
			s1=80;
		}
		if(s2>80){
			s2=80;
		}
		if(s3>80){
			s3=80;
		}
		if(s4>80){
			s4=80;
		}
		if(s1<0){
			s1=0;
		}
		if(s2<0){
			s2=0;
		}
		if(s3<0){
			s3=0;
		}
		if(s4<0){
			s4=0;
		}
	
	
	
			SetMotor(_MOTOR_1_, d1,s1);
			SetMotor(_MOTOR_2_, d2, s2);
			SetMotor(_MOTOR_3_, d3, s3);
			SetMotor(_MOTOR_4_, d4, s4); 
	
			
			
		//SetLCD5Char(0, 0, s, YELLOW, BLACK);
		//	SetLCD5Char(100, 0, d, YELLOW, BLACK);
		//	SetLCD5Char(0, 30, s1, YELLOW, BLACK);
		//	SetLCD5Char(0, 70, s2, YELLOW, BLACK);
		//	SetLCD5Char(0, 100, s3, YELLOW, BLACK);
		//	SetLCD5Char(0, 130, s4, YELLOW, BLACK);
		//	SetLCD5Char(100, 30, d1, YELLOW, BLACK);
		//	SetLCD5Char(100, 70, d2, YELLOW, BLACK);
		//	SetLCD5Char(100, 100, d3, YELLOW, BLACK);
		//	SetLCD5Char(100, 130, d4, YELLOW, BLACK);
			
	}
	
	int getXCoord(){
		int middle = (right+left)/2;
		
		if (right > left){
			return (left-middle);
		}else{
			return(middle-right);
		}
		
	}
	
	int getYCoord(){
		int middle = abs(front+back)/2;
		if(front > back){
			return(back-middle);
		}else{
			return(middle-front);
		}
	}
	
	int constrain(int value, int min, int max){
		if(value < min){
			return min;
		}
		
		if(value > max){
			return max;
		}
		return value;
	}
	
	
	
	void goToPoint(int x, int y){
		int yDiff = abs(y-getYCoord());
		int xDiff = abs(x - getXCoord());
		int angle;
		int dist = sqrt(pow(yDiff, 2) + pow(xDiff, 2));
		int relativeSpeed = constrain(dist/20, 15, 60);
		
			if(dist > 75){
				SetLCDSolidCircle(0, 0, 100, 65535);

				int ref = ( atan((yDiff * 1.0)/(xDiff)) *180.0)/ 3.14;
				
				if(y > getYCoord()){ //goal in front 
					if(x > getXCoord()){ //goal to the right - 1
						angle = 90-ref;
					}else{ //goal to the left - 2	
						angle = 270+ref;
					}
				}else{ // goal behind
					if(x > getXCoord()){ //goal to the right - 4
						angle = 90+ref;
					}else{ //goal to the left - 3
						angle = 270-ref;
					}
				
				}
				
				move(angle, relativeSpeed);
				
			}else{

				if(isHoriBlind == 1 && isVertiBlind == 1){
					SetLCDSolidCircle(0, 0, 100, 2016);
					move(-1, 0);
				}else if(isHoriBlind == 1){ //only check front and back
					SetLCDSolidCircle(0, 0, 100, 2016);
					if(front > back){
						move(0, speed);
					}else if( front < back){
						move(180, speed);
					}else{
						move(-1, 0);
					}
				}else if(isVertiBlind == 1){ //only check left and right
					SetLCDSolidCircle(0, 0, 100, 2016);
					if(left < right){
						move(90, speed);
					}else if(right > left){
						move(270, speed);
					}else{
						move(-1, 0);
					}
				}
				
			}
			
		
			
			//SetLCD5Char(0, 0, angle, YELLOW, BLACK);
		}
	
	
	void backToCenter(){
		
		if(doMove == 1){
			move(-1, 0);
		}else{
			if(abs(xdifference) < 100 && abs(ydifference) < 100){
				doMove=1;
				}else{
					if(xdifference >100){ // left side
						if(ydifference >100){ //3rd
							move(45, speed);
						}else if(ydifference <-100){//2nd
							move(135, speed);
						}else{ // between 2 and 3
							move(90, speed);
						}
					}else if (xdifference <-100){ // right side
						if(ydifference >100){ //4th
							move(315, speed);
						}else if(ydifference <-100){ //first  
							move(225, speed);
						}else{ // between 1 and 4
							move(270, speed);
						// between 1 and 4 is funny. fix it ig
							}
					}else if (xdifference > -100 && xdifference <100){ //along the y axis
						if(ydifference >100){ //between 3 and 4
							move(0, speed);
						}else{ //between 1 and 2
							move(180, speed);		
						}
					}
				}
			}
		}
	
	
	void goToBall(){
		move(getBallDirection(), speed);
	}
	
	
	void goAroundBall(){
		if(lwhere <7 || rwhere >1 ){ 
			if(isRight ==1){ // on right  side
				move(getBallDirection()+90, speed);
			}else{
				move(getBallDirection()-90, speed);
			}
		}else{
			move(0, speed);
		}
			
	}
	
	void seeWhite(){
		if(whiteRight<2450){
			startTime=GetSysTimeMs();
			while(GetSysTimeMs()<(startTime+400)){
				compass = GetCompassB(_COMPASS_compass_);
				//move(270, speed);
				backToCenter();
			}
		}else if(whiteLeft < 1900){	
			startTime=GetSysTimeMs();
			while(GetSysTimeMs()<(startTime+400)){
				compass = GetCompassB(_COMPASS_compass_);
				//move(90, speed);
				backToCenter();
	
			}
		}else if(whiteFront<1900){
			startTime=GetSysTimeMs();
			while(GetSysTimeMs()<(startTime+400)){
				compass = GetCompassB(_COMPASS_compass_);
				//move(180, speed);
				backToCenter();
	
			}
		}else if(whiteBack<1900){
			startTime=GetSysTimeMs();
			while(GetSysTimeMs()<(startTime+400)){
				compass = GetCompassB(_COMPASS_compass_);
				//move(0, speed);
				backToCenter();
	
			}
		}
	
	}
	
	void ball(){
		int angle;
		int tempDist = dist;
		if(tempDist>100) tempDist = 100;
		
		if(getBallDirection() == 0){
			angle = 0;
		}else if(getBallDirection() == 180){
			angle = 90;
		}else if(getBallDirection()> 180){
			angle = getBallDirection() - 90/(120.0)*tempDist;
		}else{
			angle = getBallDirection()+90/(120.0)*tempDist;
		}
		
		SetLCD5Char(30, 30, angle, YELLOW, BLACK);
	
		move(angle, speed);
	}
	
	int main(void){  
	
		int hori = left + right;
		int vert = front + back;
	    while(1){
		compass = GetCompassB(_COMPASS_compass_);
		right = GetAdUltrasound(_ADULTRASOUND_right_);
		left = GetAdUltrasound(_ADULTRASOUND_left_);
		front = GetAdUltrasound(_ADULTRASOUND_front_);
		back = GetAdUltrasound(_ADULTRASOUND_back_);
		xdifference = right - left;
		ydifference = front - back;
		lwhere = GetCompoI3(_COMPOUNDEYE3_left_, 8);
		ldist = GetCompoI3(_COMPOUNDEYE3_left_, 9);
		rwhere = GetCompoI3(_COMPOUNDEYE3_right_, 8);
		rdist = GetCompoI3(_COMPOUNDEYE3_right_, 9);
		whiteRight = GetADScable10(_SCABLEAD_right_);
		whiteLeft = GetADScable10(_SCABLEAD_left_);
		whiteBack = GetADScable10(_SCABLEAD_back_);
		whiteFront = GetADScable10(_SCABLEAD_front_);
		
		
		if((abs(left + right - hori) > 800)){
			isHoriBlind = 1;
		}else{
			isHoriBlind = 0;
		}
		if(abs(front + back - vert) > 800){
			isVertiBlind = 1;
		}else{
			isVertiBlind = 0;
		}
		
	
		if(ldist>rdist){
			where = lwhere;
			dist = ldist;
			isRight = 0;
		}else{
			where = rwhere;
			dist = rdist;
			isRight  =1;
		}
		
		/* 
		if(whiteRight<2000 || whiteLeft<2000 || whiteFront<2000 ||whiteBack <2000){
		    SetLCDSolidCircle(0, 0, 100, 65535);
		}else{
		    SetLCDSolidCircle(0, 0, 100, 2016);
	
		}
	
		
		if(dist<5){
			SetLCD5Char(0, 150, 0, YELLOW, BLACK);
		}else{
			SetLCD5Char(0, 150, 1, YELLOW, BLACK);
		}
		
		*/
		
	
		
		SetLCD5Char(30, 30, getXCoord(), YELLOW, BLACK);
		SetLCD5Char(30, 50, getYCoord(), YELLOW, BLACK);
	
		SetLCD5Char(150, 30, right, YELLOW, BLACK);
		SetLCD5Char(100, 30, left, YELLOW, BLACK);
		SetLCD5Char(125, 0, front, YELLOW, BLACK);
		SetLCD5Char(125, 75, back, YELLOW, BLACK);
	
		
		/*
	
		SetLCD5Char(0, 0, lwhere, YELLOW, BLACK);
		SetLCD5Char(0, 50, ldist, YELLOW, BLACK);
		SetLCD5Char(50, 0, rwhere, YELLOW, BLACK);
		SetLCD5Char(50, 50, rdist, YELLOW, BLACK);
		*/
	
	/*
		SetLCD5Char(150,100, where, YELLOW,BLACK);
		
		SetLCD5Char(150,150, dist, YELLOW,BLACK);
		
		SetLCD5Char(150,200, getBallDirection(), YELLOW,BLACK);
	*/
		
		/*
		
		if(whiteRight < 2450 || whiteLeft < 1900 || whiteFront < 1900 || whiteBack<2000){ //white line
			seeWhite();
			//SetLCDSolidCircle(0, 0, 100, 65535);
		}else{
			//SetLCDSolidCircle(0, 0, 100, 2016);
			if(ldist <=2 && rdist <=2){ //dont see bal
				backToCenter();	
			}else{	//see ball
				doMove = 0;
				ball();
			} 
		} 
		
		
		*/
		
		goToPoint(0, 0);
		
		
		
	}
	
	}
	
	
	
	/*
	what i did: started on coding the edge case for goToPoint
	
	to do: finish edge cases. there's somethign funny about the tolerance. it was at 100 and then it woudl only detect obstruction when it was completley covered on all four sides. 
	1. check teh logic to see why it requries all 4 sides to be covered
	and 2. figure out the tolernace. changed from 100 to 800 last test, and now it is not detecting blind at all
	*/